import Joi from "joi";
import { NextFunction, Request, Response } from "express";
import logger from "Utils/logger";
import SocialLogin from "Utils/SocialLogin";
import UserController from "Utils/UserController";
import IProviderError from "Types/IProviderError";
import IProviderUserData from "Types/IProviderUserData";
import IServerError from "Types/IServerError";
import IUserModel from "Types/IUserModel";
import IYandexToken from "Types/IYandexToken";
import IYandexUserData from "Types/IYandexUserData";

type IGetYandexData =
  (request: Request, response: Response, next: NextFunction) =>
    Promise<void>;

let getYandexData: IGetYandexData;

// Here we're going to form a request to the provider in order to receive the
// user data.
getYandexData = async function(
  request: Request,
  response: Response,
  next: NextFunction
): Promise<void> {

  const envSchema = Joi.object().keys({
    CLIENT_ID_YANDEX: Joi.string().min(1).required(),
    CLIENT_SECRET_YANDEX: Joi.string().min(1).required()
  });

  const { error, value: env } = Joi.validate(process.env, envSchema,
    { stripUnknown: true });

  if (error) {
    logger.error(`Client ID and client secret for Yandex are needed to be `
      + `specified as environment variables!`, error);
    return;
  }

  const socketId = request.query && request.query.state;
  const code = request.query && request.query.code;
  let token: IYandexToken | IProviderError;
  let data: IYandexUserData | IProviderError;

  // A form to request a token.
  const form = {
    client_id: env.CLIENT_ID_YANDEX || "",
    client_secret: env.CLIENT_SECRET_YANDEX || "",
    code,
    grant_type: "authorization_code"
  };

  // Request a token, then exchange it for the user data.
  try {
    token = await SocialLogin.getYandexToken(form);
    data = await SocialLogin.requestYandexData(<IYandexToken> token);
  } catch (error) {
    return next(error);
  }

  const io = request.app.get("_io");
  const isError = !!(data as IProviderError).error;

  // Maybe was authentication failed?
  if (isError)
    return io.in(socketId).emit("providerError", data);

  // If everything's fine, we're ready to let the user in. First, collect
  // all the data we need.
  const providerData = data as IYandexUserData;
  const userData: IProviderUserData = {
    birthday: providerData.birthday,
    email: providerData.default_email,
    name: providerData.display_name,
    picture: `https://avatars.yandex.net/get-yapic/${
      providerData.default_avatar_id }/islands-200`,
    provider: "yandex",
    providerId: providerData.id,
    sex: providerData.sex
  };

  const userController = new UserController();
  let user: IUserModel | null;

  // Now, if the user is presented in DB, just find them and return. Otherwise,
  // add the user to DB, and then, again, return. "userController.add" handles both
  // cases.

  try {
    user = await userController.add(userData);
  } catch (error) { // there might be an error when adding the user to DB
    const serverError: IServerError = {
      error: error.name,
      error_description: error.message
    };

    // Don't forget to send the message about the error to the client,
    // otherwise the popup window won't be closed.
    io.in(socketId).emit("serverError", serverError);
    return next(error);
  }

  // Okay, everything seems fine here. The user is in the DB, and we have their
  // ID generated by Mongo. So there's the last step remains to be taken: we
  // need to send to the client that ID so that it could create a proper
  // session for the user ("session.user") which would mean that the user was
  // finally signed in. "/auth" is the route that is responsible for creating a
  // proper session.

  io.in(socketId).emit("providerUserId", user._id);
};

export default getYandexData;